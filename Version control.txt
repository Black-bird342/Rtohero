Ahora que tenemos un control en nuestro RStudio y proyectos, hay algunas cosas más que queremos configurar antes de pasar a los otros cursos, entender el control de versiones, instalar Git, y vincular Git con RStudio. En esta lección, le daremos una comprensión básica del control de versiones. Lo primero es lo primero, ¿qué es el control de versiones? Control de versiones es un sistema que registra cambios que se realizan en un archivo o un conjunto de archivos a lo largo del tiempo. A medida que realiza ediciones, el sistema de control de versiones toma instantáneas de sus archivos y los cambios y luego guarda esas instantáneas para que pueda hacer referencia, volver a versiones anteriores más adelante si es necesario. Si alguna vez ha utilizado la función de seguimiento de cambios en Microsoft Word, ha visto un tipo rudimentario de control de versiones en el que se realiza un seguimiento de los cambios en un archivo y puede optar por conservar esas ediciones o volver al formato original. Sistemas de control de versiones como Git son como un cambio de pista más sofisticado en que, son mucho más potentes y son capaces de rastrear meticulosamente cambios sucesivos en muchos archivos con potencialmente muchas personas trabajando simultáneamente en los mismos grupos de archivos. Con suerte, una vez que haya dominado el software de control de versiones, paper final two en realidad finaldoc.docx será una cosa del pasado para usted. Como hemos visto en este ejemplo, sin control de versiones, podría estar manteniendo varias copias, muy similares de un archivo y esto podría ser peligroso. Es posible que comience a editar la versión incorrecta, no reconociendo que el documento etiquetado como final ha ha sido editado más a la final dos y ahora todos sus nuevos cambios se han aplicado al archivo incorrecto. Los sistemas de control de versiones ayudan a resolver este problema mediante manteniendo una sola versión actualizada de cada archivo con un registro de todas las versiones anteriores y un registro de exactamente lo que cambió entre las versiones que nos lleva a la siguiente ventaja importante del control de versiones. Mantiene un registro de todos los cambios realizados en los archivos. Esto puede ser de gran ayuda cuando estás colaborando con mucha gente en los mismos archivos. El software de control de versiones realiza un seguimiento de quién, cuándo y por qué se realizaron esos cambios específicos. Es como cambios de pista al extremo. Este registro también es útil para desarrollar código. Si te das cuenta después de algún tiempo de que cometiste un error e introdujiste un error, puedes encontrar la última vez que editaste el bit particular de código, ver los cambios que hiciste y volver a ese original, código intacto dejando todo lo demás que has hecho mientras tanto tocado. Finalmente, cuando se trabaja con un grupo de personas en el mismo conjunto de archivos, el control de versiones es útil para asegurarse de que no está realizando cambios en archivos que entran en conflicto con otros cambios. Si alguna vez has compartido un documento con otra persona para editarlo, sabes la frustración de integrar sus ediciones con un documento que ha cambiado desde que enviaste el archivo original. Ahora, tiene dos versiones de ese mismo documento original. El control de versiones permite que varias personas trabajen en el mismo archivo y luego ayuda a a combinar todas las versiones del archivo y todas sus ediciones en un archivo cohesivo. Git es un sistema de control de versiones libre y de código abierto. Fue desarrollado en 2005 y desde entonces se ha convertido en el sistema de control de versiones más utilizado alrededor. Desbordamiento de pila que debería sonar familiar de nuestra lección de ayuda encuestó a más de 60.000 encuestados en qué sistema de control de versiones utilizan. Como se puede ver en el gráfico, Git es de lejos el ganador. A medida que te familiarices con Git y cómo funciona en interfaces con tus proyectos, empezarás a ver por qué se ha elevado a la altura de la popularidad. Uno de los principales beneficios de Git es que mantiene una copia local de su trabajo y revisiones que luego puede netnetted offline. Luego, una vez que regrese al servicio de Internet, puede sincronizar su copia del trabajo con todos los sus nuevas ediciones y realizar un seguimiento de los cambios en el repositorio principal en línea. Además, dado que todos los colaboradores en un proyecto tenían su propia copia local del código, todos pueden trabajar simultáneamente en sus propias partes de el código sin alterar el repositorio común. Otro gran beneficio que definitivamente aprovecharemos es la facilidad con la que RStudio y Git interactúan entre sí. En la siguiente lección, trabajaremos en conseguir que Git se instale y se vincule con RStudio y crear una cuenta de GitHub. GitHub es una interfaz en línea para Git. Git es un software utilizado localmente en tu ordenador para registrar cambios. GitHub es un host para sus archivos y los registros de los cambios realizados. Puedes pensar que es similar a Dropbox. Los archivos están en su computadora pero también están alojados en línea y son accesibles desde muchos ordenadores. GitHub tiene la ventaja añadida de interactuar con Git a realizar un seguimiento de todas las versiones y cambios de sus archivos. Hay mucho vocabulario involucrado en trabajar con Git y a menudo la comprensión de una palabra depende de tu comprensión de un concepto diferente de Git. Tómese un tiempo para familiarizarse con las siguientes palabras y repasarlo un par de veces para ver cómo se relacionan los conceptos. Un repositorio es equivalente a la carpeta o directorio de proyectos. Todos sus archivos controlados de versión y los cambios registrados se encuentran en un repositorio. Esto a menudo se acorta a repositorio. Los repositorios son los que están alojados en GitHub y a través de esta interfaz puedes mantener tus repositorios privados y compartirlos con seleccionados colaboradores o puedes hacerlos públicos. Cualquiera puede ver tus archivos en su historial. Comprometer es guardar tus ediciones y los cambios realizados. Una confirmación es como una instantánea de tus archivos. Git compara la versión anterior de todos sus archivos en el repositorio con la versión actual e identifica aquellos que han cambiado desde entonces. Los que no han cambiado, mantiene ese archivo previamente almacenado intacto. Los que han cambiado, compara los archivos, carga los cambios y sube la nueva versión de tu archivo. Lo tocaremos en la siguiente sección, pero cuando cometes un archivo, normalmente acompañas ese cambio de archivo con una pequeña nota sobre lo que cambiaste y por qué. Cuando hablamos de sistemas de control de versiones, commits están en el corazón de ellos. Si encuentra un error, revertirá sus archivos a una confirmación previa. Si desea ver lo que ha cambiado en un archivo con el tiempo, compara las confirmaciones y mira los mensajes para ver por qué y quién. Empujar es actualizar el repositorio con sus ediciones. Dado que Git implica realizar cambios localmente, debe poder compartir sus cambios con el repositorio en línea común. Empujar es enviar esos cambios confirmados a ese repositorio por lo que ahora todos tienen acceso a sus ediciones. Pulling está actualizando su versión local del repositorio a la versión actual ya que otros pueden haber editado mientras tanto. Debido a que el repositorio compartido está alojado en línea en cualquiera de sus colaboradores o incluso usted mismo en una computadora diferente podría hacer cambios en los archivos y luego empujarlos al repositorio compartido. Usted está detrás de los tiempos, los archivos que tiene localmente en su computadora pueden estar obsoletos. Por lo tanto, tira para verificar si estabas al día con el repositorio principal. Un término final que debes saber es la puesta en escena que es el acto de preparar un archivo para un commit. Por ejemplo, si desde su última confirmación tiene editado tres archivos por razones completamente diferentes, no desea confirmar todos los cambios de una sola vez, su mensaje sobre por qué está haciendo la confirmación en lo que ha cambiado será complicado ya que tres archivos se han cambiado para diferentes razones. Así que, en su lugar, puede escenificar solo uno de los archivos y prepararlo para cometer. Una vez que haya confirmado ese archivo, puede poner en escena el segundo archivo y confirtarlo, etc. Staging le permite separar los cambios de archivos en commits separados, muy útil. Para resumir estos términos comúnmente utilizados hasta el momento y para probar si tiene el truco de esto, los archivos están alojados en un repositorio que se comparte en línea con los colaboradores. Extraiga el contenido del repositorio para que tenga una copia local de los archivos que puede editar. Una vez que esté satisfecho con sus cambios en un archivo, lo escenificará y lo confirmas. Empuja esta confirmación en el repositorio compartido. Esto carga tu nuevo archivo y todos los cambios y va acompañado de un mensaje explicando lo que cambió, por qué, y por quién. Una rama es cuando el mismo archivo tiene dos copias simultáneas. Cuando estaba trabajando localmente en la edición de un archivo, ha creado una rama donde sus ediciones aún no se comparten con el repositorio principal. Por lo tanto, hay dos versiones del archivo. La versión a la que todos tienen acceso en el repositorio y su versión editada local del archivo. Hasta que inserte sus cambios y los vuelva a fusionar en el repositorio principal, estás trabajando en una sucursal. Siguiendo un punto de sucursal, el historial de versiones se divide en dos y rastrea los cambios independientes realizados tanto en el archivo original en el repositorio que otros pueden estar editando y rastreando sus cambios en su rama y luego combina los archivos juntos. La fusión es cuando las ediciones independientes del mismo archivo se incorporan en un único archivo unificado. Las ediciones independientes son identificadas por Git y se reúnen en un solo archivo con ambos conjuntos de ediciones incorporadas. Pero puedes ver un problema potencial aquí. Si ambas personas hicieron una edición a la misma frase que impide que una de las ediciones sea posible, tenemos un problema. Git reconoce esta disparidad, conflicto y pide ayuda al usuario para seleccionar qué edición mantener. Entonces, un conflicto es cuando varias personas realizan cambios en el mismo archivo y Git no puede fusionar las ediciones. Se le presenta la opción de probar manualmente y combinar las ediciones o mantener una edición sobre la otra. Cuando clonas algo, estás haciendo una copia de un repositorio de Git existente. Si acaba de ser traído a un proyecto que ha sido rastreado con control de versiones, clonar el repositorio para obtener acceso y crear una versión local de todos los archivos del repositorio y todos los cambios de pista. Un tenedor es una copia personal de un repositorio que usted ha tomado de otra persona. Si alguien está trabajando en un proyecto genial y quieres jugar con él, puedes bifurcar su repositorio y luego cuando hagas cambios, las ediciones se registran en tu repositorio, no en el suyo. Puede tomar algún tiempo acostumbrarse a trabajar con software de control de versiones como Git, pero hay algunas cosas a tener en cuenta para ayudar a establecer buenos hábitos que te ayudarán en el futuro. Una de esas cosas es hacer commits intencionados. Cada confirmación solo debe tratarse como un único problema. De esta manera, si necesitas identificar cuando cambiaste una determinada línea de código, solo hay un lugar para buscar para identificar el cambio y puedes ver fácilmente cómo revertir el código. Del mismo modo, asegurarse de escribir mensajes formativos en cada compromiso es un hábito útil para entrar. Si cada mensaje es preciso en lo que se estaba cambiando, cualquiera puede examinar el archivo confirmado e identificar el propósito de su cambio. Además, si está buscando una edición específica que realizó en el pasado, puede escanear fácilmente todas sus confirmaciones a identificar los cambios relacionados con la edición deseada. Finalmente, conozca la versión de los archivos en los que está trabajando. Compruebe con frecuencia que está al día con el repositorio actual tirando con frecuencia. Además, no acumular los archivos editados. Una vez que haya confirmado sus archivos y escrito ese mensaje útil, debe enviar esos cambios al repositorio común. Si has terminado de editar una sección de código y estás planeando pasar a un problema no relacionado, necesitas compartir esa edición con tus colaboradores. Ahora que hemos cubierto qué es el control de versiones y algunos de los beneficios, debería ser capaz de entender por qué tenemos tres lecciones completas dedicadas al control de versiones e instalarlo. Miramos qué son Git y GitHub y luego cubrimos gran parte de el vocabulario comúnmente utilizado y a veces confuso inherente al trabajo de control de versiones. Luego repasamos rápidamente algunas prácticas recomendadas para usar Git, , pero la mejor manera de obtener un truco de todo esto es usarlo. Con suerte, sientes que tienes un mejor manejo de cómo funciona Git ahora. Por lo tanto, pasemos a la siguiente lección y la instalemos.